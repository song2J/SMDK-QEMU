/* AUTOMATICALLY GENERATED by qapi-gen.py DO NOT MODIFY */

/*
 * Schema-defined QAPI visitors
 *
 * Copyright IBM, Corp. 2011
 * Copyright (C) 2014-2018 Red Hat, Inc.
 *
 * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
 * See the COPYING.LIB file in the top-level directory.
 */

#include "qemu/osdep.h"
#include "qapi/error.h"
#include "qapi/qmp/qerror.h"
#include "qapi-visit-cxl.h"

bool visit_type_CxlEventLog(Visitor *v, const char *name,
                 CxlEventLog *obj, Error **errp)
{
    int value = *obj;
    bool ok = visit_type_enum(v, name, &value, &CxlEventLog_lookup, errp);
    *obj = value;
    return ok;
}

bool visit_type_q_obj_cxl_inject_general_media_event_arg_members(Visitor *v, q_obj_cxl_inject_general_media_event_arg *obj, Error **errp)
{
    bool has_component_id = !!obj->component_id;

    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CxlEventLog(v, "log", &obj->log, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "flags", &obj->flags, errp)) {
        return false;
    }
    if (!visit_type_uint64(v, "dpa", &obj->dpa, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "descriptor", &obj->descriptor, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "type", &obj->type, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "transaction-type", &obj->transaction_type, errp)) {
        return false;
    }
    if (visit_optional(v, "channel", &obj->has_channel)) {
        if (!visit_type_uint8(v, "channel", &obj->channel, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "rank", &obj->has_rank)) {
        if (!visit_type_uint8(v, "rank", &obj->rank, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "device", &obj->has_device)) {
        if (!visit_type_uint32(v, "device", &obj->device, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "component-id", &has_component_id)) {
        if (!visit_type_str(v, "component-id", &obj->component_id, errp)) {
            return false;
        }
    }
    return true;
}

bool visit_type_q_obj_cxl_inject_dram_event_arg_members(Visitor *v, q_obj_cxl_inject_dram_event_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CxlEventLog(v, "log", &obj->log, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "flags", &obj->flags, errp)) {
        return false;
    }
    if (!visit_type_uint64(v, "dpa", &obj->dpa, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "descriptor", &obj->descriptor, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "type", &obj->type, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "transaction-type", &obj->transaction_type, errp)) {
        return false;
    }
    if (visit_optional(v, "channel", &obj->has_channel)) {
        if (!visit_type_uint8(v, "channel", &obj->channel, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "rank", &obj->has_rank)) {
        if (!visit_type_uint8(v, "rank", &obj->rank, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "nibble-mask", &obj->has_nibble_mask)) {
        if (!visit_type_uint32(v, "nibble-mask", &obj->nibble_mask, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "bank-group", &obj->has_bank_group)) {
        if (!visit_type_uint8(v, "bank-group", &obj->bank_group, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "bank", &obj->has_bank)) {
        if (!visit_type_uint8(v, "bank", &obj->bank, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "row", &obj->has_row)) {
        if (!visit_type_uint32(v, "row", &obj->row, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "column", &obj->has_column)) {
        if (!visit_type_uint16(v, "column", &obj->column, errp)) {
            return false;
        }
    }
    if (visit_optional(v, "correction-mask", &obj->has_correction_mask)) {
        if (!visit_type_uint64List(v, "correction-mask", &obj->correction_mask, errp)) {
            return false;
        }
    }
    return true;
}

bool visit_type_q_obj_cxl_inject_memory_module_event_arg_members(Visitor *v, q_obj_cxl_inject_memory_module_event_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CxlEventLog(v, "log", &obj->log, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "flags", &obj->flags, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "type", &obj->type, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "health-status", &obj->health_status, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "media-status", &obj->media_status, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "additional-status", &obj->additional_status, errp)) {
        return false;
    }
    if (!visit_type_uint8(v, "life-used", &obj->life_used, errp)) {
        return false;
    }
    if (!visit_type_int16(v, "temperature", &obj->temperature, errp)) {
        return false;
    }
    if (!visit_type_uint32(v, "dirty-shutdown-count", &obj->dirty_shutdown_count, errp)) {
        return false;
    }
    if (!visit_type_uint32(v, "corrected-volatile-error-count", &obj->corrected_volatile_error_count, errp)) {
        return false;
    }
    if (!visit_type_uint32(v, "corrected-persistent-error-count", &obj->corrected_persistent_error_count, errp)) {
        return false;
    }
    return true;
}

bool visit_type_q_obj_cxl_inject_poison_arg_members(Visitor *v, q_obj_cxl_inject_poison_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_uint64(v, "start", &obj->start, errp)) {
        return false;
    }
    if (!visit_type_size(v, "length", &obj->length, errp)) {
        return false;
    }
    return true;
}

bool visit_type_CxlUncorErrorType(Visitor *v, const char *name,
                 CxlUncorErrorType *obj, Error **errp)
{
    int value = *obj;
    bool ok = visit_type_enum(v, name, &value, &CxlUncorErrorType_lookup, errp);
    *obj = value;
    return ok;
}

bool visit_type_CXLUncorErrorRecord_members(Visitor *v, CXLUncorErrorRecord *obj, Error **errp)
{
    if (!visit_type_CxlUncorErrorType(v, "type", &obj->type, errp)) {
        return false;
    }
    if (!visit_type_uint32List(v, "header", &obj->header, errp)) {
        return false;
    }
    return true;
}

bool visit_type_CXLUncorErrorRecord(Visitor *v, const char *name,
                 CXLUncorErrorRecord **obj, Error **errp)
{
    bool ok = false;

    if (!visit_start_struct(v, name, (void **)obj, sizeof(CXLUncorErrorRecord), errp)) {
        return false;
    }
    if (!*obj) {
        /* incomplete */
        assert(visit_is_dealloc(v));
        ok = true;
        goto out_obj;
    }
    if (!visit_type_CXLUncorErrorRecord_members(v, *obj, errp)) {
        goto out_obj;
    }
    ok = visit_check_struct(v, errp);
out_obj:
    visit_end_struct(v, (void **)obj);
    if (!ok && visit_is_input(v)) {
        qapi_free_CXLUncorErrorRecord(*obj);
        *obj = NULL;
    }
    return ok;
}

bool visit_type_CXLUncorErrorRecordList(Visitor *v, const char *name,
                 CXLUncorErrorRecordList **obj, Error **errp)
{
    bool ok = false;
    CXLUncorErrorRecordList *tail;
    size_t size = sizeof(**obj);

    if (!visit_start_list(v, name, (GenericList **)obj, size, errp)) {
        return false;
    }

    for (tail = *obj; tail;
         tail = (CXLUncorErrorRecordList *)visit_next_list(v, (GenericList *)tail, size)) {
        if (!visit_type_CXLUncorErrorRecord(v, NULL, &tail->value, errp)) {
            goto out_obj;
        }
    }

    ok = visit_check_list(v, errp);
out_obj:
    visit_end_list(v, (void **)obj);
    if (!ok && visit_is_input(v)) {
        qapi_free_CXLUncorErrorRecordList(*obj);
        *obj = NULL;
    }
    return ok;
}

bool visit_type_q_obj_cxl_inject_uncorrectable_errors_arg_members(Visitor *v, q_obj_cxl_inject_uncorrectable_errors_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CXLUncorErrorRecordList(v, "errors", &obj->errors, errp)) {
        return false;
    }
    return true;
}

bool visit_type_CxlCorErrorType(Visitor *v, const char *name,
                 CxlCorErrorType *obj, Error **errp)
{
    int value = *obj;
    bool ok = visit_type_enum(v, name, &value, &CxlCorErrorType_lookup, errp);
    *obj = value;
    return ok;
}

bool visit_type_q_obj_cxl_inject_correctable_error_arg_members(Visitor *v, q_obj_cxl_inject_correctable_error_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CxlCorErrorType(v, "type", &obj->type, errp)) {
        return false;
    }
    return true;
}

bool visit_type_CXLDCExtentRecord_members(Visitor *v, CXLDCExtentRecord *obj, Error **errp)
{
    if (!visit_type_uint8(v, "region-id", &obj->region_id, errp)) {
        return false;
    }
    if (!visit_type_uint64(v, "dpa", &obj->dpa, errp)) {
        return false;
    }
    if (!visit_type_uint64(v, "len", &obj->len, errp)) {
        return false;
    }
    return true;
}

bool visit_type_CXLDCExtentRecord(Visitor *v, const char *name,
                 CXLDCExtentRecord **obj, Error **errp)
{
    bool ok = false;

    if (!visit_start_struct(v, name, (void **)obj, sizeof(CXLDCExtentRecord), errp)) {
        return false;
    }
    if (!*obj) {
        /* incomplete */
        assert(visit_is_dealloc(v));
        ok = true;
        goto out_obj;
    }
    if (!visit_type_CXLDCExtentRecord_members(v, *obj, errp)) {
        goto out_obj;
    }
    ok = visit_check_struct(v, errp);
out_obj:
    visit_end_struct(v, (void **)obj);
    if (!ok && visit_is_input(v)) {
        qapi_free_CXLDCExtentRecord(*obj);
        *obj = NULL;
    }
    return ok;
}

bool visit_type_CXLDCExtentRecordList(Visitor *v, const char *name,
                 CXLDCExtentRecordList **obj, Error **errp)
{
    bool ok = false;
    CXLDCExtentRecordList *tail;
    size_t size = sizeof(**obj);

    if (!visit_start_list(v, name, (GenericList **)obj, size, errp)) {
        return false;
    }

    for (tail = *obj; tail;
         tail = (CXLDCExtentRecordList *)visit_next_list(v, (GenericList *)tail, size)) {
        if (!visit_type_CXLDCExtentRecord(v, NULL, &tail->value, errp)) {
            goto out_obj;
        }
    }

    ok = visit_check_list(v, errp);
out_obj:
    visit_end_list(v, (void **)obj);
    if (!ok && visit_is_input(v)) {
        qapi_free_CXLDCExtentRecordList(*obj);
        *obj = NULL;
    }
    return ok;
}

bool visit_type_q_obj_cxl_add_dynamic_capacity_arg_members(Visitor *v, q_obj_cxl_add_dynamic_capacity_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CXLDCExtentRecordList(v, "extents", &obj->extents, errp)) {
        return false;
    }
    return true;
}

bool visit_type_q_obj_cxl_release_dynamic_capacity_arg_members(Visitor *v, q_obj_cxl_release_dynamic_capacity_arg *obj, Error **errp)
{
    if (!visit_type_str(v, "path", &obj->path, errp)) {
        return false;
    }
    if (!visit_type_CXLDCExtentRecordList(v, "extents", &obj->extents, errp)) {
        return false;
    }
    return true;
}

/* Dummy declaration to prevent empty .o file */
char qapi_dummy_qapi_visit_cxl_c;
