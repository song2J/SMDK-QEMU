/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_SSI_GENERATED_TRACERS_H
#define TRACE_HW_SSI_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_FLASH_READ_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_DO_SNOOP_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_FLASH_WRITE_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_READ_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_DMA_CHECKSUM_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_DMA_RW_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_WRITE_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_FLASH_SELECT_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_ENTER_RESET_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_HOLD_RESET_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_SELECT_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_DESELECT_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_CTRL_READ_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_FLASH_READ_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_FLASH_WRITE_EVENT;
extern TraceEvent _TRACE_NPCM_PSPI_ENTER_RESET_EVENT;
extern TraceEvent _TRACE_NPCM_PSPI_CTRL_READ_EVENT;
extern TraceEvent _TRACE_NPCM_PSPI_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_RESET_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_TRANSFER_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_WRITE_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_READ_EVENT;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_READ_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_DO_SNOOP_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_WRITE_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_READ_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_DMA_CHECKSUM_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_DMA_RW_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_WRITE_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_SELECT_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_ENTER_RESET_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_HOLD_RESET_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_SELECT_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_DESELECT_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_CTRL_READ_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_FLASH_READ_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_FLASH_WRITE_DSTATE;
extern uint16_t _TRACE_NPCM_PSPI_ENTER_RESET_DSTATE;
extern uint16_t _TRACE_NPCM_PSPI_CTRL_READ_DSTATE;
extern uint16_t _TRACE_NPCM_PSPI_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_RESET_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_TRANSFER_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_WRITE_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_READ_DSTATE;
#define TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_ENABLED 1
#define TRACE_ASPEED_SMC_FLASH_READ_ENABLED 1
#define TRACE_ASPEED_SMC_DO_SNOOP_ENABLED 1
#define TRACE_ASPEED_SMC_FLASH_WRITE_ENABLED 1
#define TRACE_ASPEED_SMC_READ_ENABLED 1
#define TRACE_ASPEED_SMC_DMA_CHECKSUM_ENABLED 1
#define TRACE_ASPEED_SMC_DMA_RW_ENABLED 1
#define TRACE_ASPEED_SMC_WRITE_ENABLED 1
#define TRACE_ASPEED_SMC_FLASH_SELECT_ENABLED 1
#define TRACE_NPCM7XX_FIU_ENTER_RESET_ENABLED 1
#define TRACE_NPCM7XX_FIU_HOLD_RESET_ENABLED 1
#define TRACE_NPCM7XX_FIU_SELECT_ENABLED 1
#define TRACE_NPCM7XX_FIU_DESELECT_ENABLED 1
#define TRACE_NPCM7XX_FIU_CTRL_READ_ENABLED 1
#define TRACE_NPCM7XX_FIU_CTRL_WRITE_ENABLED 1
#define TRACE_NPCM7XX_FIU_FLASH_READ_ENABLED 1
#define TRACE_NPCM7XX_FIU_FLASH_WRITE_ENABLED 1
#define TRACE_NPCM_PSPI_ENTER_RESET_ENABLED 1
#define TRACE_NPCM_PSPI_CTRL_READ_ENABLED 1
#define TRACE_NPCM_PSPI_CTRL_WRITE_ENABLED 1
#define TRACE_IBEX_SPI_HOST_RESET_ENABLED 1
#define TRACE_IBEX_SPI_HOST_TRANSFER_ENABLED 1
#define TRACE_IBEX_SPI_HOST_WRITE_ENABLED 1
#define TRACE_IBEX_SPI_HOST_READ_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_SET_SEGMENT) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_set_segment(int cs, uint64_t reg, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_SET_SEGMENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_set_segment " "CS%d segreg=0x%"PRIx64" [ 0x%"PRIx64" - 0x%"PRIx64" ]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, reg, start, end);
#line 100 "trace/trace-hw_ssi.h"
        } else {
#line 3 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_set_segment " "CS%d segreg=0x%"PRIx64" [ 0x%"PRIx64" - 0x%"PRIx64" ]" "\n", cs, reg, start, end);
#line 104 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_set_segment(int cs, uint64_t reg, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_set_segment(cs, reg, start, end);
    }
}

#define TRACE_ASPEED_SMC_FLASH_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_READ) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_read(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_read " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, addr, size, data, mode);
#line 131 "trace/trace-hw_ssi.h"
        } else {
#line 4 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_read " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n", cs, addr, size, data, mode);
#line 135 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_read(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_read(cs, addr, size, data, mode);
    }
}

#define TRACE_ASPEED_SMC_DO_SNOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_DO_SNOOP) || \
    false)

static inline void _nocheck__trace_aspeed_smc_do_snoop(int cs, int index, int dummies, int data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_DO_SNOOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_do_snoop " "CS%d index:0x%x dummies:%d data:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, index, dummies, data);
#line 162 "trace/trace-hw_ssi.h"
        } else {
#line 5 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_do_snoop " "CS%d index:0x%x dummies:%d data:0x%x" "\n", cs, index, dummies, data);
#line 166 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_do_snoop(int cs, int index, int dummies, int data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_do_snoop(cs, index, dummies, data);
    }
}

#define TRACE_ASPEED_SMC_FLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_WRITE) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_write(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_write " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, addr, size, data, mode);
#line 193 "trace/trace-hw_ssi.h"
        } else {
#line 6 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_write " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n", cs, addr, size, data, mode);
#line 197 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_write(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_write(cs, addr, size, data, mode);
    }
}

#define TRACE_ASPEED_SMC_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_READ) || \
    false)

static inline void _nocheck__trace_aspeed_smc_read(uint64_t addr, uint32_t size, uint64_t data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_read " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 224 "trace/trace-hw_ssi.h"
        } else {
#line 7 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_read " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n", addr, size, data);
#line 228 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_read(uint64_t addr, uint32_t size, uint64_t data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_read(addr, size, data);
    }
}

#define TRACE_ASPEED_SMC_DMA_CHECKSUM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_DMA_CHECKSUM) || \
    false)

static inline void _nocheck__trace_aspeed_smc_dma_checksum(uint32_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_DMA_CHECKSUM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_dma_checksum " "0x%08x: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 255 "trace/trace-hw_ssi.h"
        } else {
#line 8 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_dma_checksum " "0x%08x: 0x%08x" "\n", addr, data);
#line 259 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_dma_checksum(uint32_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_dma_checksum(addr, data);
    }
}

#define TRACE_ASPEED_SMC_DMA_RW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_DMA_RW) || \
    false)

static inline void _nocheck__trace_aspeed_smc_dma_rw(const char * dir, uint32_t flash_addr, uint32_t dram_addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_DMA_RW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_dma_rw " "%s flash:@0x%08x dram:@0x%08x size:0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dir, flash_addr, dram_addr, size);
#line 286 "trace/trace-hw_ssi.h"
        } else {
#line 9 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_dma_rw " "%s flash:@0x%08x dram:@0x%08x size:0x%08x" "\n", dir, flash_addr, dram_addr, size);
#line 290 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_dma_rw(const char * dir, uint32_t flash_addr, uint32_t dram_addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_aspeed_smc_dma_rw(dir, flash_addr, dram_addr, size);
    }
}

#define TRACE_ASPEED_SMC_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_WRITE) || \
    false)

static inline void _nocheck__trace_aspeed_smc_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 317 "trace/trace-hw_ssi.h"
        } else {
#line 10 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n", addr, size, data);
#line 321 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_write(addr, size, data);
    }
}

#define TRACE_ASPEED_SMC_FLASH_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_SELECT) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_select(int cs, const char * prefix)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_select " "CS%d %sselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, prefix);
#line 348 "trace/trace-hw_ssi.h"
        } else {
#line 11 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_select " "CS%d %sselect" "\n", cs, prefix);
#line 352 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_select(int cs, const char * prefix)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_select(cs, prefix);
    }
}

#define TRACE_NPCM7XX_FIU_ENTER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_ENTER_RESET) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_enter_reset(const char * id, int reset_type)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_ENTER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_enter_reset " "%s reset type: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, reset_type);
#line 379 "trace/trace-hw_ssi.h"
        } else {
#line 15 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_enter_reset " "%s reset type: %d" "\n", id, reset_type);
#line 383 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_enter_reset(const char * id, int reset_type)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_enter_reset(id, reset_type);
    }
}

#define TRACE_NPCM7XX_FIU_HOLD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_HOLD_RESET) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_hold_reset(const char * id)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_HOLD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_hold_reset " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 410 "trace/trace-hw_ssi.h"
        } else {
#line 16 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_hold_reset " "%s" "\n", id);
#line 414 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_hold_reset(const char * id)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_hold_reset(id);
    }
}

#define TRACE_NPCM7XX_FIU_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_SELECT) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_select(const char * id, int cs)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_select " "%s select CS%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs);
#line 441 "trace/trace-hw_ssi.h"
        } else {
#line 17 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_select " "%s select CS%d" "\n", id, cs);
#line 445 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_select(const char * id, int cs)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_select(id, cs);
    }
}

#define TRACE_NPCM7XX_FIU_DESELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_DESELECT) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_deselect(const char * id, int cs)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_DESELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_deselect " "%s deselect CS%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs);
#line 472 "trace/trace-hw_ssi.h"
        } else {
#line 18 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_deselect " "%s deselect CS%d" "\n", id, cs);
#line 476 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_deselect(const char * id, int cs)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_deselect(id, cs);
    }
}

#define TRACE_NPCM7XX_FIU_CTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_CTRL_READ) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_ctrl_read(const char * id, uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_CTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_ctrl_read " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 503 "trace/trace-hw_ssi.h"
        } else {
#line 19 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_ctrl_read " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n", id, addr, data);
#line 507 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_ctrl_read(const char * id, uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_ctrl_read(id, addr, data);
    }
}

#define TRACE_NPCM7XX_FIU_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_ctrl_write(const char * id, uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_ctrl_write " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 534 "trace/trace-hw_ssi.h"
        } else {
#line 20 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_ctrl_write " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n", id, addr, data);
#line 538 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_ctrl_write(const char * id, uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_ctrl_write(id, addr, data);
    }
}

#define TRACE_NPCM7XX_FIU_FLASH_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_FLASH_READ) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_flash_read(const char * id, int cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_FLASH_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_flash_read " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs, addr, size, value);
#line 565 "trace/trace-hw_ssi.h"
        } else {
#line 21 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_flash_read " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n", id, cs, addr, size, value);
#line 569 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_flash_read(const char * id, int cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_flash_read(id, cs, addr, size, value);
    }
}

#define TRACE_NPCM7XX_FIU_FLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_FLASH_WRITE) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_flash_write(const char * id, unsigned cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_FLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_flash_write " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs, addr, size, value);
#line 596 "trace/trace-hw_ssi.h"
        } else {
#line 22 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_flash_write " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n", id, cs, addr, size, value);
#line 600 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_flash_write(const char * id, unsigned cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_flash_write(id, cs, addr, size, value);
    }
}

#define TRACE_NPCM_PSPI_ENTER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM_PSPI_ENTER_RESET) || \
    false)

static inline void _nocheck__trace_npcm_pspi_enter_reset(const char * id, int reset_type)
{
    if (trace_event_get_state(TRACE_NPCM_PSPI_ENTER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm_pspi_enter_reset " "%s reset type: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, reset_type);
#line 627 "trace/trace-hw_ssi.h"
        } else {
#line 25 "../hw/ssi/trace-events"
            qemu_log("npcm_pspi_enter_reset " "%s reset type: %d" "\n", id, reset_type);
#line 631 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm_pspi_enter_reset(const char * id, int reset_type)
{
    if (true) {
        _nocheck__trace_npcm_pspi_enter_reset(id, reset_type);
    }
}

#define TRACE_NPCM_PSPI_CTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM_PSPI_CTRL_READ) || \
    false)

static inline void _nocheck__trace_npcm_pspi_ctrl_read(const char * id, uint64_t addr, uint16_t data)
{
    if (trace_event_get_state(TRACE_NPCM_PSPI_CTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm_pspi_ctrl_read " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 658 "trace/trace-hw_ssi.h"
        } else {
#line 26 "../hw/ssi/trace-events"
            qemu_log("npcm_pspi_ctrl_read " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n", id, addr, data);
#line 662 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm_pspi_ctrl_read(const char * id, uint64_t addr, uint16_t data)
{
    if (true) {
        _nocheck__trace_npcm_pspi_ctrl_read(id, addr, data);
    }
}

#define TRACE_NPCM_PSPI_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM_PSPI_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_npcm_pspi_ctrl_write(const char * id, uint64_t addr, uint16_t data)
{
    if (trace_event_get_state(TRACE_NPCM_PSPI_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm_pspi_ctrl_write " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 689 "trace/trace-hw_ssi.h"
        } else {
#line 27 "../hw/ssi/trace-events"
            qemu_log("npcm_pspi_ctrl_write " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n", id, addr, data);
#line 693 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm_pspi_ctrl_write(const char * id, uint64_t addr, uint16_t data)
{
    if (true) {
        _nocheck__trace_npcm_pspi_ctrl_write(id, addr, data);
    }
}

#define TRACE_IBEX_SPI_HOST_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_RESET) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_reset(const char * msg)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_reset " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 720 "trace/trace-hw_ssi.h"
        } else {
#line 31 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_reset " "%s" "\n", msg);
#line 724 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_reset(const char * msg)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_reset(msg);
    }
}

#define TRACE_IBEX_SPI_HOST_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_TRANSFER) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_transfer(uint32_t tx_data, uint32_t rx_data)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_transfer " "tx_data: 0x%" PRIx32 " rx_data: @0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_data, rx_data);
#line 751 "trace/trace-hw_ssi.h"
        } else {
#line 32 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_transfer " "tx_data: 0x%" PRIx32 " rx_data: @0x%" PRIx32 "\n", tx_data, rx_data);
#line 755 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_transfer(uint32_t tx_data, uint32_t rx_data)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_transfer(tx_data, rx_data);
    }
}

#define TRACE_IBEX_SPI_HOST_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_WRITE) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 782 "trace/trace-hw_ssi.h"
        } else {
#line 33 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n", addr, size, data);
#line 786 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_write(addr, size, data);
    }
}

#define TRACE_IBEX_SPI_HOST_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_READ) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_read(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_read " "@0x%" PRIx64 " size %u:" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 813 "trace/trace-hw_ssi.h"
        } else {
#line 34 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_read " "@0x%" PRIx64 " size %u:" "\n", addr, size);
#line 817 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_read(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_read(addr, size);
    }
}
#endif /* TRACE_HW_SSI_GENERATED_TRACERS_H */
