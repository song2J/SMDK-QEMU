/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_XEN_GENERATED_TRACERS_H
#define TRACE_HW_XEN_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_XEN_DEFAULT_IOREQ_SERVER_EVENT;
extern TraceEvent _TRACE_XEN_IOREQ_SERVER_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_IOREQ_SERVER_DESTROY_EVENT;
extern TraceEvent _TRACE_XEN_IOREQ_SERVER_STATE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_MMIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_UNMAP_MMIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_PORTIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_UNMAP_PORTIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_PCIDEV_EVENT;
extern TraceEvent _TRACE_XEN_UNMAP_PCIDEV_EVENT;
extern TraceEvent _TRACE_XEN_DOMID_RESTRICT_EVENT;
extern TraceEvent _TRACE_XEN_BUS_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_ENUMERATE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_CLEANUP_EVENT;
extern TraceEvent _TRACE_XEN_BUS_TYPE_ENUMERATE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_BACKEND_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_DEVICE_CLEANUP_EVENT;
extern TraceEvent _TRACE_XEN_BUS_ADD_WATCH_EVENT;
extern TraceEvent _TRACE_XEN_BUS_REMOVE_WATCH_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_BACKEND_STATE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_BACKEND_ONLINE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_BACKEND_CHANGED_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_FRONTEND_STATE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_FRONTEND_CHANGED_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_UNPLUG_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_ADD_WATCH_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_REMOVE_WATCH_EVENT;
extern TraceEvent _TRACE_XS_NODE_CREATE_EVENT;
extern TraceEvent _TRACE_XS_NODE_DESTROY_EVENT;
extern TraceEvent _TRACE_XS_NODE_VPRINTF_EVENT;
extern TraceEvent _TRACE_XS_NODE_VSCANF_EVENT;
extern TraceEvent _TRACE_XS_NODE_WATCH_EVENT;
extern TraceEvent _TRACE_XS_NODE_UNWATCH_EVENT;
extern TraceEvent _TRACE_XEN_RAM_ALLOC_EVENT;
extern TraceEvent _TRACE_XEN_CLIENT_SET_MEMORY_EVENT;
extern TraceEvent _TRACE_HANDLE_IOREQ_EVENT;
extern TraceEvent _TRACE_HANDLE_IOREQ_READ_EVENT;
extern TraceEvent _TRACE_HANDLE_IOREQ_WRITE_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_PIO_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_PIO_READ_REG_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_PIO_WRITE_REG_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_MOVE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_RESOURCE_IOREQ_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_CONFIG_READ_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_CONFIG_WRITE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_CACHE_EVENT;
extern TraceEvent _TRACE_XEN_REMAP_BUCKET_EVENT;
extern TraceEvent _TRACE_XEN_MAP_CACHE_RETURN_EVENT;
extern uint16_t _TRACE_XEN_DEFAULT_IOREQ_SERVER_DSTATE;
extern uint16_t _TRACE_XEN_IOREQ_SERVER_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_IOREQ_SERVER_DESTROY_DSTATE;
extern uint16_t _TRACE_XEN_IOREQ_SERVER_STATE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_MMIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_UNMAP_MMIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_PORTIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_UNMAP_PORTIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_PCIDEV_DSTATE;
extern uint16_t _TRACE_XEN_UNMAP_PCIDEV_DSTATE;
extern uint16_t _TRACE_XEN_DOMID_RESTRICT_DSTATE;
extern uint16_t _TRACE_XEN_BUS_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_ENUMERATE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_CLEANUP_DSTATE;
extern uint16_t _TRACE_XEN_BUS_TYPE_ENUMERATE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_BACKEND_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_DEVICE_CLEANUP_DSTATE;
extern uint16_t _TRACE_XEN_BUS_ADD_WATCH_DSTATE;
extern uint16_t _TRACE_XEN_BUS_REMOVE_WATCH_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_BACKEND_STATE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_BACKEND_ONLINE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_BACKEND_CHANGED_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_FRONTEND_STATE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_FRONTEND_CHANGED_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_UNPLUG_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_ADD_WATCH_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_REMOVE_WATCH_DSTATE;
extern uint16_t _TRACE_XS_NODE_CREATE_DSTATE;
extern uint16_t _TRACE_XS_NODE_DESTROY_DSTATE;
extern uint16_t _TRACE_XS_NODE_VPRINTF_DSTATE;
extern uint16_t _TRACE_XS_NODE_VSCANF_DSTATE;
extern uint16_t _TRACE_XS_NODE_WATCH_DSTATE;
extern uint16_t _TRACE_XS_NODE_UNWATCH_DSTATE;
extern uint16_t _TRACE_XEN_RAM_ALLOC_DSTATE;
extern uint16_t _TRACE_XEN_CLIENT_SET_MEMORY_DSTATE;
extern uint16_t _TRACE_HANDLE_IOREQ_DSTATE;
extern uint16_t _TRACE_HANDLE_IOREQ_READ_DSTATE;
extern uint16_t _TRACE_HANDLE_IOREQ_WRITE_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_PIO_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_PIO_READ_REG_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_PIO_WRITE_REG_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_MOVE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_RESOURCE_IOREQ_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_CONFIG_READ_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_CONFIG_WRITE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_CACHE_DSTATE;
extern uint16_t _TRACE_XEN_REMAP_BUCKET_DSTATE;
extern uint16_t _TRACE_XEN_MAP_CACHE_RETURN_DSTATE;
#define TRACE_XEN_DEFAULT_IOREQ_SERVER_ENABLED 1
#define TRACE_XEN_IOREQ_SERVER_CREATE_ENABLED 1
#define TRACE_XEN_IOREQ_SERVER_DESTROY_ENABLED 1
#define TRACE_XEN_IOREQ_SERVER_STATE_ENABLED 1
#define TRACE_XEN_MAP_MMIO_RANGE_ENABLED 1
#define TRACE_XEN_UNMAP_MMIO_RANGE_ENABLED 1
#define TRACE_XEN_MAP_PORTIO_RANGE_ENABLED 1
#define TRACE_XEN_UNMAP_PORTIO_RANGE_ENABLED 1
#define TRACE_XEN_MAP_PCIDEV_ENABLED 1
#define TRACE_XEN_UNMAP_PCIDEV_ENABLED 1
#define TRACE_XEN_DOMID_RESTRICT_ENABLED 1
#define TRACE_XEN_BUS_REALIZE_ENABLED 1
#define TRACE_XEN_BUS_UNREALIZE_ENABLED 1
#define TRACE_XEN_BUS_ENUMERATE_ENABLED 1
#define TRACE_XEN_BUS_CLEANUP_ENABLED 1
#define TRACE_XEN_BUS_TYPE_ENUMERATE_ENABLED 1
#define TRACE_XEN_BUS_BACKEND_CREATE_ENABLED 1
#define TRACE_XEN_BUS_DEVICE_CLEANUP_ENABLED 1
#define TRACE_XEN_BUS_ADD_WATCH_ENABLED 1
#define TRACE_XEN_BUS_REMOVE_WATCH_ENABLED 1
#define TRACE_XEN_DEVICE_REALIZE_ENABLED 1
#define TRACE_XEN_DEVICE_UNREALIZE_ENABLED 1
#define TRACE_XEN_DEVICE_BACKEND_STATE_ENABLED 1
#define TRACE_XEN_DEVICE_BACKEND_ONLINE_ENABLED 1
#define TRACE_XEN_DEVICE_BACKEND_CHANGED_ENABLED 1
#define TRACE_XEN_DEVICE_FRONTEND_STATE_ENABLED 1
#define TRACE_XEN_DEVICE_FRONTEND_CHANGED_ENABLED 1
#define TRACE_XEN_DEVICE_UNPLUG_ENABLED 1
#define TRACE_XEN_DEVICE_ADD_WATCH_ENABLED 1
#define TRACE_XEN_DEVICE_REMOVE_WATCH_ENABLED 1
#define TRACE_XS_NODE_CREATE_ENABLED 1
#define TRACE_XS_NODE_DESTROY_ENABLED 1
#define TRACE_XS_NODE_VPRINTF_ENABLED 1
#define TRACE_XS_NODE_VSCANF_ENABLED 1
#define TRACE_XS_NODE_WATCH_ENABLED 1
#define TRACE_XS_NODE_UNWATCH_ENABLED 1
#define TRACE_XEN_RAM_ALLOC_ENABLED 1
#define TRACE_XEN_CLIENT_SET_MEMORY_ENABLED 1
#define TRACE_HANDLE_IOREQ_ENABLED 1
#define TRACE_HANDLE_IOREQ_READ_ENABLED 1
#define TRACE_HANDLE_IOREQ_WRITE_ENABLED 1
#define TRACE_CPU_IOREQ_PIO_ENABLED 1
#define TRACE_CPU_IOREQ_PIO_READ_REG_ENABLED 1
#define TRACE_CPU_IOREQ_PIO_WRITE_REG_ENABLED 1
#define TRACE_CPU_IOREQ_MOVE_ENABLED 1
#define TRACE_XEN_MAP_RESOURCE_IOREQ_ENABLED 1
#define TRACE_CPU_IOREQ_CONFIG_READ_ENABLED 1
#define TRACE_CPU_IOREQ_CONFIG_WRITE_ENABLED 1
#define TRACE_XEN_MAP_CACHE_ENABLED 1
#define TRACE_XEN_REMAP_BUCKET_ENABLED 1
#define TRACE_XEN_MAP_CACHE_RETURN_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_XEN_DEFAULT_IOREQ_SERVER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEFAULT_IOREQ_SERVER) || \
    false)

static inline void _nocheck__trace_xen_default_ioreq_server(void)
{
    if (trace_event_get_state(TRACE_XEN_DEFAULT_IOREQ_SERVER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_default_ioreq_server " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 181 "trace/trace-hw_xen.h"
        } else {
#line 4 "../hw/xen/trace-events"
            qemu_log("xen_default_ioreq_server " "" "\n");
#line 185 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_default_ioreq_server(void)
{
    if (true) {
        _nocheck__trace_xen_default_ioreq_server();
    }
}

#define TRACE_XEN_IOREQ_SERVER_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_IOREQ_SERVER_CREATE) || \
    false)

static inline void _nocheck__trace_xen_ioreq_server_create(uint32_t id)
{
    if (trace_event_get_state(TRACE_XEN_IOREQ_SERVER_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ioreq_server_create " "id: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 212 "trace/trace-hw_xen.h"
        } else {
#line 5 "../hw/xen/trace-events"
            qemu_log("xen_ioreq_server_create " "id: %u" "\n", id);
#line 216 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ioreq_server_create(uint32_t id)
{
    if (true) {
        _nocheck__trace_xen_ioreq_server_create(id);
    }
}

#define TRACE_XEN_IOREQ_SERVER_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_IOREQ_SERVER_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_ioreq_server_destroy(uint32_t id)
{
    if (trace_event_get_state(TRACE_XEN_IOREQ_SERVER_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ioreq_server_destroy " "id: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 243 "trace/trace-hw_xen.h"
        } else {
#line 6 "../hw/xen/trace-events"
            qemu_log("xen_ioreq_server_destroy " "id: %u" "\n", id);
#line 247 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ioreq_server_destroy(uint32_t id)
{
    if (true) {
        _nocheck__trace_xen_ioreq_server_destroy(id);
    }
}

#define TRACE_XEN_IOREQ_SERVER_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_IOREQ_SERVER_STATE) || \
    false)

static inline void _nocheck__trace_xen_ioreq_server_state(uint32_t id, bool enable)
{
    if (trace_event_get_state(TRACE_XEN_IOREQ_SERVER_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ioreq_server_state " "id: %u: enable: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, enable);
#line 274 "trace/trace-hw_xen.h"
        } else {
#line 7 "../hw/xen/trace-events"
            qemu_log("xen_ioreq_server_state " "id: %u: enable: %i" "\n", id, enable);
#line 278 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ioreq_server_state(uint32_t id, bool enable)
{
    if (true) {
        _nocheck__trace_xen_ioreq_server_state(id, enable);
    }
}

#define TRACE_XEN_MAP_MMIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_MMIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_map_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_MMIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 305 "trace/trace-hw_xen.h"
        } else {
#line 8 "../hw/xen/trace-events"
            qemu_log("xen_map_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 309 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_map_mmio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_UNMAP_MMIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_UNMAP_MMIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_unmap_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_UNMAP_MMIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_unmap_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 336 "trace/trace-hw_xen.h"
        } else {
#line 9 "../hw/xen/trace-events"
            qemu_log("xen_unmap_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 340 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_unmap_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_unmap_mmio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_MAP_PORTIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_PORTIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_map_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_PORTIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 367 "trace/trace-hw_xen.h"
        } else {
#line 10 "../hw/xen/trace-events"
            qemu_log("xen_map_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 371 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_map_portio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_UNMAP_PORTIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_UNMAP_PORTIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_unmap_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_UNMAP_PORTIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_unmap_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 398 "trace/trace-hw_xen.h"
        } else {
#line 11 "../hw/xen/trace-events"
            qemu_log("xen_unmap_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 402 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_unmap_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_unmap_portio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_MAP_PCIDEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_PCIDEV) || \
    false)

static inline void _nocheck__trace_xen_map_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (trace_event_get_state(TRACE_XEN_MAP_PCIDEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, bus, dev, func);
#line 429 "trace/trace-hw_xen.h"
        } else {
#line 12 "../hw/xen/trace-events"
            qemu_log("xen_map_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n", id, bus, dev, func);
#line 433 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (true) {
        _nocheck__trace_xen_map_pcidev(id, bus, dev, func);
    }
}

#define TRACE_XEN_UNMAP_PCIDEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_UNMAP_PCIDEV) || \
    false)

static inline void _nocheck__trace_xen_unmap_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (trace_event_get_state(TRACE_XEN_UNMAP_PCIDEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_unmap_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, bus, dev, func);
#line 460 "trace/trace-hw_xen.h"
        } else {
#line 13 "../hw/xen/trace-events"
            qemu_log("xen_unmap_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n", id, bus, dev, func);
#line 464 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_unmap_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (true) {
        _nocheck__trace_xen_unmap_pcidev(id, bus, dev, func);
    }
}

#define TRACE_XEN_DOMID_RESTRICT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DOMID_RESTRICT) || \
    false)

static inline void _nocheck__trace_xen_domid_restrict(int err)
{
    if (trace_event_get_state(TRACE_XEN_DOMID_RESTRICT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_domid_restrict " "err: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 491 "trace/trace-hw_xen.h"
        } else {
#line 14 "../hw/xen/trace-events"
            qemu_log("xen_domid_restrict " "err: %u" "\n", err);
#line 495 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_domid_restrict(int err)
{
    if (true) {
        _nocheck__trace_xen_domid_restrict(err);
    }
}

#define TRACE_XEN_BUS_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_bus_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 522 "trace/trace-hw_xen.h"
        } else {
#line 17 "../hw/xen/trace-events"
            qemu_log("xen_bus_realize " "" "\n");
#line 526 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_realize(void)
{
    if (true) {
        _nocheck__trace_xen_bus_realize();
    }
}

#define TRACE_XEN_BUS_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_bus_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 553 "trace/trace-hw_xen.h"
        } else {
#line 18 "../hw/xen/trace-events"
            qemu_log("xen_bus_unrealize " "" "\n");
#line 557 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_bus_unrealize();
    }
}

#define TRACE_XEN_BUS_ENUMERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_ENUMERATE) || \
    false)

static inline void _nocheck__trace_xen_bus_enumerate(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_ENUMERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_enumerate " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 584 "trace/trace-hw_xen.h"
        } else {
#line 19 "../hw/xen/trace-events"
            qemu_log("xen_bus_enumerate " "" "\n");
#line 588 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_enumerate(void)
{
    if (true) {
        _nocheck__trace_xen_bus_enumerate();
    }
}

#define TRACE_XEN_BUS_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_CLEANUP) || \
    false)

static inline void _nocheck__trace_xen_bus_cleanup(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_cleanup " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 615 "trace/trace-hw_xen.h"
        } else {
#line 20 "../hw/xen/trace-events"
            qemu_log("xen_bus_cleanup " "" "\n");
#line 619 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_cleanup(void)
{
    if (true) {
        _nocheck__trace_xen_bus_cleanup();
    }
}

#define TRACE_XEN_BUS_TYPE_ENUMERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_TYPE_ENUMERATE) || \
    false)

static inline void _nocheck__trace_xen_bus_type_enumerate(const char * type)
{
    if (trace_event_get_state(TRACE_XEN_BUS_TYPE_ENUMERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_type_enumerate " "type: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 646 "trace/trace-hw_xen.h"
        } else {
#line 21 "../hw/xen/trace-events"
            qemu_log("xen_bus_type_enumerate " "type: %s" "\n", type);
#line 650 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_type_enumerate(const char * type)
{
    if (true) {
        _nocheck__trace_xen_bus_type_enumerate(type);
    }
}

#define TRACE_XEN_BUS_BACKEND_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_BACKEND_CREATE) || \
    false)

static inline void _nocheck__trace_xen_bus_backend_create(const char * type, const char * path)
{
    if (trace_event_get_state(TRACE_XEN_BUS_BACKEND_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_backend_create " "type: %s path: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, path);
#line 677 "trace/trace-hw_xen.h"
        } else {
#line 22 "../hw/xen/trace-events"
            qemu_log("xen_bus_backend_create " "type: %s path: %s" "\n", type, path);
#line 681 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_backend_create(const char * type, const char * path)
{
    if (true) {
        _nocheck__trace_xen_bus_backend_create(type, path);
    }
}

#define TRACE_XEN_BUS_DEVICE_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_DEVICE_CLEANUP) || \
    false)

static inline void _nocheck__trace_xen_bus_device_cleanup(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_BUS_DEVICE_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_device_cleanup " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 708 "trace/trace-hw_xen.h"
        } else {
#line 23 "../hw/xen/trace-events"
            qemu_log("xen_bus_device_cleanup " "type: %s name: %s" "\n", type, name);
#line 712 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_device_cleanup(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_bus_device_cleanup(type, name);
    }
}

#define TRACE_XEN_BUS_ADD_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_ADD_WATCH) || \
    false)

static inline void _nocheck__trace_xen_bus_add_watch(const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_BUS_ADD_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_add_watch " "node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node, key);
#line 739 "trace/trace-hw_xen.h"
        } else {
#line 24 "../hw/xen/trace-events"
            qemu_log("xen_bus_add_watch " "node: %s key: %s" "\n", node, key);
#line 743 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_add_watch(const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_bus_add_watch(node, key);
    }
}

#define TRACE_XEN_BUS_REMOVE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_REMOVE_WATCH) || \
    false)

static inline void _nocheck__trace_xen_bus_remove_watch(const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_BUS_REMOVE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_remove_watch " "node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node, key);
#line 770 "trace/trace-hw_xen.h"
        } else {
#line 25 "../hw/xen/trace-events"
            qemu_log("xen_bus_remove_watch " "node: %s key: %s" "\n", node, key);
#line 774 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_remove_watch(const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_bus_remove_watch(node, key);
    }
}

#define TRACE_XEN_DEVICE_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_device_realize(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_realize " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 801 "trace/trace-hw_xen.h"
        } else {
#line 26 "../hw/xen/trace-events"
            qemu_log("xen_device_realize " "type: %s name: %s" "\n", type, name);
#line 805 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_realize(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_realize(type, name);
    }
}

#define TRACE_XEN_DEVICE_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_device_unrealize(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_unrealize " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 832 "trace/trace-hw_xen.h"
        } else {
#line 27 "../hw/xen/trace-events"
            qemu_log("xen_device_unrealize " "type: %s name: %s" "\n", type, name);
#line 836 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_unrealize(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_unrealize(type, name);
    }
}

#define TRACE_XEN_DEVICE_BACKEND_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_BACKEND_STATE) || \
    false)

static inline void _nocheck__trace_xen_device_backend_state(const char * type, char * name, const char * state)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_BACKEND_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_backend_state " "type: %s name: %s -> %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, state);
#line 863 "trace/trace-hw_xen.h"
        } else {
#line 28 "../hw/xen/trace-events"
            qemu_log("xen_device_backend_state " "type: %s name: %s -> %s" "\n", type, name, state);
#line 867 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_backend_state(const char * type, char * name, const char * state)
{
    if (true) {
        _nocheck__trace_xen_device_backend_state(type, name, state);
    }
}

#define TRACE_XEN_DEVICE_BACKEND_ONLINE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_BACKEND_ONLINE) || \
    false)

static inline void _nocheck__trace_xen_device_backend_online(const char * type, char * name, bool online)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_BACKEND_ONLINE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_backend_online " "type: %s name: %s -> %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, online);
#line 894 "trace/trace-hw_xen.h"
        } else {
#line 29 "../hw/xen/trace-events"
            qemu_log("xen_device_backend_online " "type: %s name: %s -> %u" "\n", type, name, online);
#line 898 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_backend_online(const char * type, char * name, bool online)
{
    if (true) {
        _nocheck__trace_xen_device_backend_online(type, name, online);
    }
}

#define TRACE_XEN_DEVICE_BACKEND_CHANGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_BACKEND_CHANGED) || \
    false)

static inline void _nocheck__trace_xen_device_backend_changed(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_BACKEND_CHANGED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_backend_changed " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 925 "trace/trace-hw_xen.h"
        } else {
#line 30 "../hw/xen/trace-events"
            qemu_log("xen_device_backend_changed " "type: %s name: %s" "\n", type, name);
#line 929 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_backend_changed(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_backend_changed(type, name);
    }
}

#define TRACE_XEN_DEVICE_FRONTEND_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_FRONTEND_STATE) || \
    false)

static inline void _nocheck__trace_xen_device_frontend_state(const char * type, char * name, const char * state)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_FRONTEND_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_frontend_state " "type: %s name: %s -> %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, state);
#line 956 "trace/trace-hw_xen.h"
        } else {
#line 31 "../hw/xen/trace-events"
            qemu_log("xen_device_frontend_state " "type: %s name: %s -> %s" "\n", type, name, state);
#line 960 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_frontend_state(const char * type, char * name, const char * state)
{
    if (true) {
        _nocheck__trace_xen_device_frontend_state(type, name, state);
    }
}

#define TRACE_XEN_DEVICE_FRONTEND_CHANGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_FRONTEND_CHANGED) || \
    false)

static inline void _nocheck__trace_xen_device_frontend_changed(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_FRONTEND_CHANGED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_frontend_changed " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 987 "trace/trace-hw_xen.h"
        } else {
#line 32 "../hw/xen/trace-events"
            qemu_log("xen_device_frontend_changed " "type: %s name: %s" "\n", type, name);
#line 991 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_frontend_changed(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_frontend_changed(type, name);
    }
}

#define TRACE_XEN_DEVICE_UNPLUG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_UNPLUG) || \
    false)

static inline void _nocheck__trace_xen_device_unplug(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_UNPLUG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_unplug " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 1018 "trace/trace-hw_xen.h"
        } else {
#line 33 "../hw/xen/trace-events"
            qemu_log("xen_device_unplug " "type: %s name: %s" "\n", type, name);
#line 1022 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_unplug(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_unplug(type, name);
    }
}

#define TRACE_XEN_DEVICE_ADD_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_ADD_WATCH) || \
    false)

static inline void _nocheck__trace_xen_device_add_watch(const char * type, char * name, const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_ADD_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_add_watch " "type: %s name: %s node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, node, key);
#line 1049 "trace/trace-hw_xen.h"
        } else {
#line 34 "../hw/xen/trace-events"
            qemu_log("xen_device_add_watch " "type: %s name: %s node: %s key: %s" "\n", type, name, node, key);
#line 1053 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_add_watch(const char * type, char * name, const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_device_add_watch(type, name, node, key);
    }
}

#define TRACE_XEN_DEVICE_REMOVE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_REMOVE_WATCH) || \
    false)

static inline void _nocheck__trace_xen_device_remove_watch(const char * type, char * name, const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_REMOVE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_remove_watch " "type: %s name: %s node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, node, key);
#line 1080 "trace/trace-hw_xen.h"
        } else {
#line 35 "../hw/xen/trace-events"
            qemu_log("xen_device_remove_watch " "type: %s name: %s node: %s key: %s" "\n", type, name, node, key);
#line 1084 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_remove_watch(const char * type, char * name, const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_device_remove_watch(type, name, node, key);
    }
}

#define TRACE_XS_NODE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_CREATE) || \
    false)

static inline void _nocheck__trace_xs_node_create(const char * node)
{
    if (trace_event_get_state(TRACE_XS_NODE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_create " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node);
#line 1111 "trace/trace-hw_xen.h"
        } else {
#line 38 "../hw/xen/trace-events"
            qemu_log("xs_node_create " "%s" "\n", node);
#line 1115 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_create(const char * node)
{
    if (true) {
        _nocheck__trace_xs_node_create(node);
    }
}

#define TRACE_XS_NODE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_DESTROY) || \
    false)

static inline void _nocheck__trace_xs_node_destroy(const char * node)
{
    if (trace_event_get_state(TRACE_XS_NODE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_destroy " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node);
#line 1142 "trace/trace-hw_xen.h"
        } else {
#line 39 "../hw/xen/trace-events"
            qemu_log("xs_node_destroy " "%s" "\n", node);
#line 1146 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_destroy(const char * node)
{
    if (true) {
        _nocheck__trace_xs_node_destroy(node);
    }
}

#define TRACE_XS_NODE_VPRINTF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_VPRINTF) || \
    false)

static inline void _nocheck__trace_xs_node_vprintf(char * path, char * value)
{
    if (trace_event_get_state(TRACE_XS_NODE_VPRINTF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_vprintf " "%s %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, value);
#line 1173 "trace/trace-hw_xen.h"
        } else {
#line 40 "../hw/xen/trace-events"
            qemu_log("xs_node_vprintf " "%s %s" "\n", path, value);
#line 1177 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_vprintf(char * path, char * value)
{
    if (true) {
        _nocheck__trace_xs_node_vprintf(path, value);
    }
}

#define TRACE_XS_NODE_VSCANF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_VSCANF) || \
    false)

static inline void _nocheck__trace_xs_node_vscanf(char * path, char * value)
{
    if (trace_event_get_state(TRACE_XS_NODE_VSCANF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_vscanf " "%s %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, value);
#line 1204 "trace/trace-hw_xen.h"
        } else {
#line 41 "../hw/xen/trace-events"
            qemu_log("xs_node_vscanf " "%s %s" "\n", path, value);
#line 1208 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_vscanf(char * path, char * value)
{
    if (true) {
        _nocheck__trace_xs_node_vscanf(path, value);
    }
}

#define TRACE_XS_NODE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_WATCH) || \
    false)

static inline void _nocheck__trace_xs_node_watch(char * path)
{
    if (trace_event_get_state(TRACE_XS_NODE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_watch " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path);
#line 1235 "trace/trace-hw_xen.h"
        } else {
#line 42 "../hw/xen/trace-events"
            qemu_log("xs_node_watch " "%s" "\n", path);
#line 1239 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_watch(char * path)
{
    if (true) {
        _nocheck__trace_xs_node_watch(path);
    }
}

#define TRACE_XS_NODE_UNWATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_UNWATCH) || \
    false)

static inline void _nocheck__trace_xs_node_unwatch(char * path)
{
    if (trace_event_get_state(TRACE_XS_NODE_UNWATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_unwatch " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path);
#line 1266 "trace/trace-hw_xen.h"
        } else {
#line 43 "../hw/xen/trace-events"
            qemu_log("xs_node_unwatch " "%s" "\n", path);
#line 1270 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_unwatch(char * path)
{
    if (true) {
        _nocheck__trace_xs_node_unwatch(path);
    }
}

#define TRACE_XEN_RAM_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_RAM_ALLOC) || \
    false)

static inline void _nocheck__trace_xen_ram_alloc(unsigned long ram_addr, unsigned long size)
{
    if (trace_event_get_state(TRACE_XEN_RAM_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ram_alloc " "requested: 0x%lx, size 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ram_addr, size);
#line 1297 "trace/trace-hw_xen.h"
        } else {
#line 46 "../hw/xen/trace-events"
            qemu_log("xen_ram_alloc " "requested: 0x%lx, size 0x%lx" "\n", ram_addr, size);
#line 1301 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ram_alloc(unsigned long ram_addr, unsigned long size)
{
    if (true) {
        _nocheck__trace_xen_ram_alloc(ram_addr, size);
    }
}

#define TRACE_XEN_CLIENT_SET_MEMORY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CLIENT_SET_MEMORY) || \
    false)

static inline void _nocheck__trace_xen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty)
{
    if (trace_event_get_state(TRACE_XEN_CLIENT_SET_MEMORY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_client_set_memory " "0x%"PRIx64" size 0x%lx, log_dirty %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start_addr, size, log_dirty);
#line 1328 "trace/trace-hw_xen.h"
        } else {
#line 47 "../hw/xen/trace-events"
            qemu_log("xen_client_set_memory " "0x%"PRIx64" size 0x%lx, log_dirty %i" "\n", start_addr, size, log_dirty);
#line 1332 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty)
{
    if (true) {
        _nocheck__trace_xen_client_set_memory(start_addr, size, log_dirty);
    }
}

#define TRACE_HANDLE_IOREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_IOREQ) || \
    false)

static inline void _nocheck__trace_handle_ioreq(void * req, uint32_t type, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_HANDLE_IOREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:handle_ioreq " "I/O=%p type=%d dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, type, dir, df, data_is_ptr, addr, data, count, size);
#line 1359 "trace/trace-hw_xen.h"
        } else {
#line 48 "../hw/xen/trace-events"
            qemu_log("handle_ioreq " "I/O=%p type=%d dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, type, dir, df, data_is_ptr, addr, data, count, size);
#line 1363 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_handle_ioreq(void * req, uint32_t type, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_handle_ioreq(req, type, dir, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_HANDLE_IOREQ_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_IOREQ_READ) || \
    false)

static inline void _nocheck__trace_handle_ioreq_read(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_HANDLE_IOREQ_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:handle_ioreq_read " "I/O=%p read type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, type, df, data_is_ptr, addr, data, count, size);
#line 1390 "trace/trace-hw_xen.h"
        } else {
#line 49 "../hw/xen/trace-events"
            qemu_log("handle_ioreq_read " "I/O=%p read type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, type, df, data_is_ptr, addr, data, count, size);
#line 1394 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_handle_ioreq_read(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_handle_ioreq_read(req, type, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_HANDLE_IOREQ_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_IOREQ_WRITE) || \
    false)

static inline void _nocheck__trace_handle_ioreq_write(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_HANDLE_IOREQ_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:handle_ioreq_write " "I/O=%p write type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, type, df, data_is_ptr, addr, data, count, size);
#line 1421 "trace/trace-hw_xen.h"
        } else {
#line 50 "../hw/xen/trace-events"
            qemu_log("handle_ioreq_write " "I/O=%p write type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, type, df, data_is_ptr, addr, data, count, size);
#line 1425 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_handle_ioreq_write(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_handle_ioreq_write(req, type, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_CPU_IOREQ_PIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_PIO) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_pio(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_PIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_pio " "I/O=%p pio dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, dir, df, data_is_ptr, addr, data, count, size);
#line 1452 "trace/trace-hw_xen.h"
        } else {
#line 51 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_pio " "I/O=%p pio dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, dir, df, data_is_ptr, addr, data, count, size);
#line 1456 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_pio(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_pio(req, dir, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_CPU_IOREQ_PIO_READ_REG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_PIO_READ_REG) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_pio_read_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_PIO_READ_REG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_pio_read_reg " "I/O=%p pio read reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, data, addr, size);
#line 1483 "trace/trace-hw_xen.h"
        } else {
#line 52 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_pio_read_reg " "I/O=%p pio read reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n", req, data, addr, size);
#line 1487 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_pio_read_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_pio_read_reg(req, data, addr, size);
    }
}

#define TRACE_CPU_IOREQ_PIO_WRITE_REG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_PIO_WRITE_REG) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_pio_write_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_PIO_WRITE_REG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_pio_write_reg " "I/O=%p pio write reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, data, addr, size);
#line 1514 "trace/trace-hw_xen.h"
        } else {
#line 53 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_pio_write_reg " "I/O=%p pio write reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n", req, data, addr, size);
#line 1518 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_pio_write_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_pio_write_reg(req, data, addr, size);
    }
}

#define TRACE_CPU_IOREQ_MOVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_MOVE) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_move(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_MOVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_move " "I/O=%p copy dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, dir, df, data_is_ptr, addr, data, count, size);
#line 1545 "trace/trace-hw_xen.h"
        } else {
#line 54 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_move " "I/O=%p copy dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, dir, df, data_is_ptr, addr, data, count, size);
#line 1549 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_move(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_move(req, dir, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_XEN_MAP_RESOURCE_IOREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_RESOURCE_IOREQ) || \
    false)

static inline void _nocheck__trace_xen_map_resource_ioreq(uint32_t id, void * addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_RESOURCE_IOREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_resource_ioreq " "id: %u addr: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr);
#line 1576 "trace/trace-hw_xen.h"
        } else {
#line 55 "../hw/xen/trace-events"
            qemu_log("xen_map_resource_ioreq " "id: %u addr: %p" "\n", id, addr);
#line 1580 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_resource_ioreq(uint32_t id, void * addr)
{
    if (true) {
        _nocheck__trace_xen_map_resource_ioreq(id, addr);
    }
}

#define TRACE_CPU_IOREQ_CONFIG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_CONFIG_READ) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_config_read(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_CONFIG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_config_read " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, sbdf, reg, size, data);
#line 1607 "trace/trace-hw_xen.h"
        } else {
#line 56 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_config_read " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n", req, sbdf, reg, size, data);
#line 1611 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_config_read(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_config_read(req, sbdf, reg, size, data);
    }
}

#define TRACE_CPU_IOREQ_CONFIG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_CONFIG_WRITE) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_config_write(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_CONFIG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_config_write " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, sbdf, reg, size, data);
#line 1638 "trace/trace-hw_xen.h"
        } else {
#line 57 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_config_write " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n", req, sbdf, reg, size, data);
#line 1642 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_config_write(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_config_write(req, sbdf, reg, size, data);
    }
}

#define TRACE_XEN_MAP_CACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_CACHE) || \
    false)

static inline void _nocheck__trace_xen_map_cache(uint64_t phys_addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_CACHE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_cache " "want 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , phys_addr);
#line 1669 "trace/trace-hw_xen.h"
        } else {
#line 60 "../hw/xen/trace-events"
            qemu_log("xen_map_cache " "want 0x%"PRIx64 "\n", phys_addr);
#line 1673 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_cache(uint64_t phys_addr)
{
    if (true) {
        _nocheck__trace_xen_map_cache(phys_addr);
    }
}

#define TRACE_XEN_REMAP_BUCKET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_REMAP_BUCKET) || \
    false)

static inline void _nocheck__trace_xen_remap_bucket(uint64_t index)
{
    if (trace_event_get_state(TRACE_XEN_REMAP_BUCKET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_remap_bucket " "index 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1700 "trace/trace-hw_xen.h"
        } else {
#line 61 "../hw/xen/trace-events"
            qemu_log("xen_remap_bucket " "index 0x%"PRIx64 "\n", index);
#line 1704 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_remap_bucket(uint64_t index)
{
    if (true) {
        _nocheck__trace_xen_remap_bucket(index);
    }
}

#define TRACE_XEN_MAP_CACHE_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_CACHE_RETURN) || \
    false)

static inline void _nocheck__trace_xen_map_cache_return(void* ptr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_CACHE_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_cache_return " "%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ptr);
#line 1731 "trace/trace-hw_xen.h"
        } else {
#line 62 "../hw/xen/trace-events"
            qemu_log("xen_map_cache_return " "%p" "\n", ptr);
#line 1735 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_cache_return(void* ptr)
{
    if (true) {
        _nocheck__trace_xen_map_cache_return(ptr);
    }
}
#endif /* TRACE_HW_XEN_GENERATED_TRACERS_H */
